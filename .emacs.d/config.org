#+TITLE: alxdb's Emacs Config
#+AUTHOR: alxdb

#+PROPERTY: header-args :results silent

* Base Settings
Modifying the default behaviour of Emacs.

** Use-Package
Package to manage packages.
https://github.com/jwiegley/use-package

*** Bootstrap Use-Package
All settings are configured within =use-package= declarations. ~:ensure t~ is
used for external packages, built-in packages do not use this.  Settings which
are not part of any specific package, use the special use-package declaration
=use-package emacs=.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (eval-when-compile
    (require 'use-package))
#+END_SRC

*** Delight
Some active modes are displayed in the modeline as "lighters". The =delight=
package allows for editing these lighters. =use-package= also has a special
~:delight~ tag for editing these.

#+BEGIN_SRC emacs-lisp
  (use-package delight
    :ensure t
    :after use-package)
#+END_SRC

** Cleanup Emacs File Barf
By default Emacs creates a lot of files everywhere, we want to reign that in.

*** Seperate File for Customizations
By default, customizations are put into =init.el=. Putting customizations into
a seperate file allows them to be independent of version control, and also
prevents cluttering the =init.el= file.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (custom-file (concat user-emacs-directory "custom.el"))
    :config
    (unless (file-exists-p custom-file)
      (with-temp-buffer
	(insert ";; custom.el")
	(write-file custom-file nil)))
    (load custom-file))
#+END_SRC

*** Backup Files
Instead of cluttering up working directories with files, use a specific
directory to store autosave files. Also force copying of autosave files
rather than symlinking them, and a few other autosave options.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (backup-by-copying t)
    (version-control t)
    (backup-directory-alist
     `((".*" . ,(concat user-emacs-directory "backup-files"))))
    (delete-old-versions t)
    (kept-new-versions 2)
    (kept-old-versions 2))
#+END_SRC

*** Auto-Save Files
Same thing for auto-saved files as for backup files, don't clutter my
directories with =#filename.foo#= etc.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (auto-save-file-name-transforms
     `((".*" ,(concat user-emacs-directory "auto-save") t))))
#+END_SRC

** Visuals
Make Emacs look pretty.

*** Clean GUI
Make Emacs GUI nice and clean by removing all the GTK elements.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (use-dialog-box nil)
    (inhibit-startup-screen t)
    (initial-scratch-message nil)
    (menu-bar-mode nil)
    (tool-bar-mode nil)
    :config
    (set-scroll-bar-mode nil))
#+END_SRC

*** Theme
Gruvbox is the best theme so I'll install that. At the moment I'm liking the
hard dark theme.

#+BEGIN_SRC emacs-lisp
  (use-package gruvbox-theme
    :ensure t
    :config
    (load-theme 'gruvbox-dark-hard))
#+END_SRC

*** Font
Why Emacs doesn't just use the standard monospace font, I don't know. Let's make
it do that.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (set-face-attribute 'default nil
                        :family "Monospace"
                        :height 90))
#+END_SRC

*** Spaceline
The default Emacs modeline is kinda gross. Let's fix that.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t)
  (use-package spaceline-config
    :custom (spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
    :config
    (spaceline-spacemacs-theme)
    (set-face-attribute 'powerline-active1 nil
                        :background "#282828")
    (set-face-attribute 'spaceline-highlight-face nil
                        :background "#83a598")
    (set-face-attribute 'spaceline-evil-normal nil
                        :background "#83a598")
    (set-face-attribute 'spaceline-evil-insert nil
                        :background "#8ec07c")
    (set-face-attribute 'spaceline-evil-emacs nil
                        :background "#d3869b"))
#+END_SRC

** Tweaks
Miscellaneous changes to mould Emacs to my liking.

*** Spaces over Tabs
I know... but I think it allows greater control over indentation.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (indent-tabs-mode nil))
#+END_SRC

*** Electric Pair Mode
Automatically insert pairs of brackets. Much like =electric-indent-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (electric-pair-mode))
#+END_SRC

*** Show Formfeed as Line
Some views in Emacs use this weird =^L= character, which is meant to be the
formfeed character. Something that maybe didn't really take off, and is not
rendered particularly nicely. The following config renders it as a line in
various modes.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (defun xah-show-formfeed-as-line ()
      (interactive)
      (progn
	(when (not buffer-display-table)
	  (setq buffer-display-table (make-display-table)))
	(aset buffer-display-table ?\^L
	      (vconcat (make-list 80 (make-glyph-code ?- 'font-lock-comment-face))))
	(redraw-frame)))
    :hook
    ((help-mode compilation-mode) . xah-show-formfeed-as-line))
#+END_SRC

*** Window Spliting
Emacs's =split-window-sensibly= function prefers splitting windows vertically
(downwards). I prefer horizontal splitting by default, So I'll define a new
function which copies the Emacs function but prefers splitting horizontally.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (defun adb-split-window-sensibly (&optional window)
    "`split-window-sensibly' I've just swapped the horizontal and vertical checks"
    (let ((window (or window (selected-window))))
      (or (and (window-splittable-p window t)
               ;; Split window horizontally.
               (with-selected-window window
                 (split-window-right)))
          (and (window-splittable-p window)
               ;; Split window vertically.
               (with-selected-window window
                 (split-window-below)))
          (and
           ;; If WINDOW is the only usable window on its frame (it is
           ;; the only one or, not being the only one, all the other
           ;; ones are dedicated) and is not the minibuffer window, try
           ;; to split it horizontally disregarding the value of
           ;; `split-width-threshold'.
           (let ((frame (window-frame window)))
             (or
              (eq window (frame-root-window frame))
              (catch 'done
                (walk-window-tree (lambda (w)
                                    (unless (or (eq w window)
                                                (window-dedicated-p w))
                                      (throw 'done nil)))
                                  frame)
                t)))
           (not (window-minibuffer-p window))
           (let ((split-width-threshold 0))
             (when (window-splittable-p window)
               (with-selected-window window
                 (split-window-right))))))))
    :custom
    (split-window-preferred-function 'adb-split-window-sensibly)
    (split-width-threshold 300))
#+END_SRC

*** Doc View Resolution
The default doc-view resolution (used for viewing pdf documents etc.) is quite
low. We can increase it. We have the technology.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (doc-view-resolution 192))
#+END_SRC

*** Set Fill Column
70 charaters is ridiculous, 80 is much better.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (fill-column 80))
#+END_SRC

*** Keybinding to edit config
I'm going to edit this file a lot, it would be convenient to have a keybinding to open it.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :bind ("C-x c" . (lambda ()
                       (interactive)
                       (find-file "~/.emacs.d/config.org"))))
#+END_SRC

** Org-mode
Org mode is great, here are some tweaks.

*** Babel Enabled Languages
Enable babel support for specified languages.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :custom
    (org-babel-load-languages '((emacs-lisp . t)
				(python . t))))
#+END_SRC

*** Org Src Window Setup
By default =C-'= in org mode edits a src code block (among other
things) and reorganizes the frame to do it. This change makes that a
split window instead.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :custom
    (org-src-window-setup 'other-window))
#+END_SRC 

* Enhancements
Things that enhance or extend Emacs's behaviour.

** Quality of Life
Extra packages which make life just a little better.

*** Which-Key
Although available keybindings can be queried by using =C-h= while entering a
command, it's not the most convinient way to discover keybindings. =which-key=
will popup available keybindings after a timeout, and has some other neat
features. I also prefer to have the popup be manually triggered rather than
using a timeout.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :delight
    :custom
    (which-key-show-early-on-C-h t)
    (which-key-idle-delay 10000)
    (which-key-idle-secondary-delay 0.05)
    :config
    (which-key-mode))
#+END_SRC

*** Ivy and Swiper
_flexible, simple tools for minibuffer completion in Emacs_
Ivy enhances minibuffer completion in Emacs. Swiper enhances i-search by
enabling fuzzy search and giving an overview of matches in the minibuffer. Both
are required by counsel, so installing that will pull in the other two as
dependencies.

Counsel redefines some common completion commands to ones which work better
with ivy.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :config
    (ivy-mode)
    (counsel-mode))
#+END_SRC

Since these modes will pretty much always be enabled, I don't need to see their
lighters.

#+BEGIN_SRC emacs-lisp
  (use-package ivy :delight)
  (use-package counsel :delight)
#+END_SRC

I'm also going to replace the =C-s= keybinding which defaults to
=isearch-forward= with =swiper= and =C-M-s=, which is usually bound to
=isearch-forward-regexp= with =swiper-thing-at-point=.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind (("C-s" . swiper)
	   ("C-M-s" . swiper-thing-at-point)))
#+END_SRC 

*** Ace-Window
Ace-window allows jumping to specific windows using on screen numbers. The
readme recommends =M-o= as the main keybinding, but this is already bound by
default in emacs. I will use =C-x M-o= as it is a more mnemonic Emacs
keybinding, and is unbound by default.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :bind (("C-x M-o" . ace-window))
    :custom (aw-keys '(97 115 100 102 113 119 101 114)))
#+END_SRC

*** Restart-Emacs
Sometimes, particularly when editing Emacs's config, I need to restart Emacs.
Emacs doesn't have a built in way to do this, so this package adds that command.

#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :ensure t)
#+END_SRC

*** Writeroom
Distraction free editing.

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :ensure t)
#+END_SRC

*** Rainbow Delimiters
Because who doesn't like rainbows? Also, very useful for lisp. The modes this is
active in is defined here.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook (clojure-mode . rainbow-delimiters-mode))
#+END_SRC

*** Persp Mode
Provides tagged workspaces, like in tiling window managers. Spaceline will
display the current workspace, so I will remove the lighter. I'm also going to
set a bunch of config options to what I prefer.

There are a lot of elisp snippets on Bad-ptr's github for configuring various
other packages to work with persp-mode. I'm going to translate a few into
use-package parlance, and put them in subheadings.

#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :ensure t
    :delight
    :bind-keymap
    ("C-x M-p" . persp-key-map)
    :custom
    (*persp-restrict-buffers-to* 0)
    (persp-autokill-buffer-on-remove 'kill-weak)
    (persp-autokill-persp-when-removed-last-buffer 'kill-auto)
    (persp-set-read-buffer-function t)
    (persp-auto-resume-time 0)
    :config
    (persp-mode 1))
#+END_SRC

**** Ivy Integration
This configures ivy to ignore buffers that aren't in the current
perspective. Also tells ivy not to sort the completion options to various
pserp-mode functions. Likely becuase persp mode does this itself.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :config
    (add-to-list 'ivy-ignore-buffers
                 #'(lambda (b)
                     (when persp-mode
                       (let ((persp (get-current-persp)))
                         (if persp
                             (not (persp-contain-buffer-p b persp))
                           nil)))))
    (add-to-list 'ivy-sort-functions-alist 
                 '((persp-kill-buffer   . nil)
                   (persp-remove-buffer . nil)
                   (persp-add-buffer    . nil)
                   (persp-switch        . nil)
                   (persp-window-switch . nil)
                   (persp-frame-switch  . nil))))
#+END_SRC

**** Projectile Integration
Create perspectives which switching to projects etc. etc. like in spacemacs.

#+BEGIN_SRC emacs-lisp
  (use-package persp-mode
    :config
    (defvar persp-mode-projectile-bridge-before-switch-selected-window-buffer nil)

    (persp-def-auto-persp
     "projectile"
     :parameters '((dont-save-to-file . t)
                   (persp-mode-projectile-bridge . t))
     :hooks '(projectile-before-switch-project-hook
              projectile-after-switch-project-hook
              projectile-find-file-hook
              find-file-hook)
     :dyn-env '((after-switch-to-buffer-adv-suspend t))
     :switch 'frame
     :predicate
     #'(lambda (buffer &optional state)
         (if (eq 'projectile-before-switch-project-hook
                 (alist-get 'hook state))
             state
           (and
            projectile-mode
            (buffer-live-p buffer)
            (buffer-file-name buffer)
            ;; (not git-commit-mode)
            (projectile-project-p)
            (or state t))))
     :get-name
     #'(lambda (state)
         (if (eq 'projectile-before-switch-project-hook
                 (alist-get 'hook state))
             state
           (push (cons 'persp-name
                       (with-current-buffer (alist-get 'buffer state)
                         (projectile-project-name)))
                 state)
           state))
     :on-match
     #'(lambda (state)
         (let ((hook (alist-get 'hook state))
               (persp (alist-get 'persp state))
               (buffer (alist-get 'buffer state)))
           (case hook
             (projectile-before-switch-project-hook
              (let ((win (if (minibuffer-window-active-p (selected-window))
                             (minibuffer-selected-window)
                           (selected-window))))
                (when (window-live-p win)
                  (setq persp-mode-projectile-bridge-before-switch-selected-window-buffer
                        (window-buffer win)))))

             (projectile-after-switch-project-hook
              (when (buffer-live-p
                     persp-mode-projectile-bridge-before-switch-selected-window-buffer)
                (let ((win (selected-window)))
                  (unless (eq (window-buffer win)
                              persp-mode-projectile-bridge-before-switch-selected-window-buffer)
                    (set-window-buffer
                     win persp-mode-projectile-bridge-before-switch-selected-window-buffer)))))

             (find-file-hook
              (setcdr (assq :switch state) nil)))
           (if (case hook
                 (projectile-before-switch-project-hook nil)
                 (t t))
               (persp--auto-persp-default-on-match state)
             (setcdr (assq :after-match state) nil)))
         state)
     :after-match
     #'(lambda (state)
         (when (eq 'find-file-hook (alist-get 'hook state))
           (run-at-time 0.5 nil
                        #'(lambda (buf persp)
                            (when (and (eq persp (get-current-persp))
                                       (not (eq buf (window-buffer (selected-window)))))
                              ;; (switch-to-buffer buf)
                              (persp-add-buffer buf persp t nil)))
                        (alist-get 'buffer state)
                        (get-current-persp)))
         (persp--auto-persp-default-after-match state))))
#+END_SRC

**** TODO Make better spaceline segment for persp-mode

** Project Management
Tools to manage projects with Emacs.

*** Magit
Magit is a frontend for git, some say the best frontend for git. It has all the
features of it's command line counterpart, but with the advantage of being
interactive and visually rich. Almost every Emacs user should have this package.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t)
#+END_SRC

*** Projectile
Projectile is a way of managing projects within Emacs. It allows grouping of
buffer by project, and running commands that act on an entire project. It is
extremely useful for developing software in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :delight
    :custom
    (projectile-completion-system 'ivy)
    :config
    (projectile-mode)
    :bind-keymap
    ("C-x p" . projectile-command-map))
#+END_SRC

**** Search
projectile requires ~ag.el~ in order to do project wide searches.

#+BEGIN_SRC emacs-lisp
  (use-package ag
    :ensure t)
#+END_SRC

** IDEish
*** Company
Basically completion, just with more features and backends than the emacs
default (one of those backends is the default emacs completion system).

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :delight "CY"
    :hook (after-init . global-company-mode))
#+END_SRC

*** Flycheck
Again, basically flymake but supports more languages, backends and has a few
more features.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :delight "FC"
    :custom
    (flycheck-emacs-lisp-load-path 'inherit)
    (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    :init (global-flycheck-mode))
#+END_SRC

I also like my errors to be inline.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-inline
    :ensure t
    :after (flycheck)
    :hook (flycheck-mode . flycheck-inline-mode))
#+END_SRC

*** LSP
For languages that support it, it's great. I'm only enabling this as a hook for
languages that support it.

I'm going to use the standard ~lsp-mode~ package, which is more or less why I
installed the previous packages. ~elglot~ is also feasable, but it's a lot less
popular, and even the author of it says that there's probably not much
difference any more between them.

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :hook (rust-mode)
    :custom (lsp-prefer-flymake nil))
#+END_SRC

For Company support:

#+BEGIN_SRC emacs-lisp
  (use-package company-lsp
    :ensure t
    :config
    (push 'company-lsp company-backends))
#+END_SRC

For Flycheck support:

#+BEGIN_SRC emacs-lisp
  (use-package lsp-ui
    :ensure t
    :hook (lsp-mode . lsp-ui-mode)
    :custom (lsp-ui-flycheck-enable t))
#+END_SRC

** Extra Major Modes
Extra modes for various types of files

*** Programming
**** Clojure
Cider's all you need.

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t)
#+END_SRC

Sometime the repl will spit out a ridiculously long line. I really don't need to
see it most of the time.

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :hook (cider-repl-mode . toggle-truncate-lines))
#+END_SRC

#+RESULTS:

**** GLSL
Yay graphics n' stuff

#+BEGIN_SRC emacs-lisp
  (use-package glsl-mode
    :ensure t)
#+END_SRC

***** Flycheck

Add a checker for flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :init
    (flycheck-define-checker glsl-lang-validator
      "See URL https://www.khronos.org/opengles/sdk/tools/Reference-Compiler"
      :command ("glslangValidator" source)
      :error-patterns ((error line-start "ERROR: " column ":" line ": " (message) line-end))
      :modes glsl-mode)
    (add-to-list 'flycheck-checkers 'glsl-lang-validator))
#+END_SRC

**** Haskell
First of all, I install the major mode.
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t)
#+END_SRC

**** JavaScript
I'm a sadist.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :custom (js2-missing-semi-one-line-override t)
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
    (add-to-list 'interpreter-mode-alist '("node" . js2-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package npm-mode
    :delight
    :ensure t
    :hook (js2-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ac-js2
    :ensure
    :hook (js2-mode . ac-js2-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package web-beautify
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (use-package js-comint
    ;; :ensure t
    ;; :bind (("C-x C-e" . js-send-last-sexp)
           ;; ("C-c b" . js-send-buffer)
           ;; ("C-c C-z" . js-comint-start-or-switch-to-repl)))
#+END_SRC

**** Nasm
0110

#+BEGIN_SRC emacs-lisp
  (use-package nasm
    :ensure t
    :mode ("\\.\\(asm\\|s\\)$" . nasm-mode))
#+END_SRC

**** Rust
Stuff for make rust work good.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :custom (rust-format-on-save t))

  (use-package cargo
    :ensure
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC

*** Markup
**** Markdown
It's everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

*** Data
**** Yaml
Use for lots of conf files.

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t)
#+END_SRC

**** Json

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t)
#+END_SRC

*** Misc
**** Restclient
Good for testing out APIs.

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure t)
#+END_SRC

**** Ob-http
http blocks in org mode.

#+BEGIN_SRC emacs-lisp
  (use-package ob-http
    :ensure t)
#+END_SRC

** Evil
Lord forgive me, for I have sinned.

*** Base
I've tried using the emacs keybindings for a little bit now, and while I am able
to edit text somewhat efficiently, I know vim keybindings much better, and I
think they are a bit more powerful. However, I don't want to try and replace
every system in emacs with vim style keybindings since, Emacs is still Emacs
(additionally, in certain scenarios, like command lines, Emacs keybindings are
more appropriate). Instead I will make the default evil state the ~emacs~ state,
then for certain modes, make ~normal~ the inital state.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :custom (evil-default-state 'emacs)
    :config
    (evil-mode 1)
    (setq adb-evil-major-modes '(prog-mode org-mode))
    (mapc (lambda (mode) (evil-set-initial-state mode 'normal))
          adb-evil-major-modes))
#+END_SRC

*** Undo Tree
For the moment, I just want to change the lighter.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :delight (undo-tree-mode "UT"))
#+END_SRC

*** Unbindings
Some vim keybindings mess with emacs defaults or other packages. This is where I
remove those.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :bind (:map evil-normal-state-map
                ("M-." . nil)))
#+END_SRC

*** CleverParens
Modal lispy editing.

#+BEGIN_SRC emacs-lisp
  (use-package evil-cleverparens
    :ensure t
    :delight "CP"
    :custom (evil-mode-beyond-eol t) ; as suggested in readme
    :hook ((clojure-mode emacs-lisp-mode) . evil-cleverparens-mode))

  (use-package evil-cleverparens-text-objects) ; to get forms/comments/defuns as text-objects
#+END_SRC

*** Folding
This is the basic form of folding. To keep things simple, I'm just going to
enable ~hs-minor-mode~ in the same places I use evil normal mode as the inital
mode.

#+BEGIN_SRC emacs-lisp
  (use-package hideshow
    :delight (hs-minor-mode "HS")
    :hook ((prog-mode org-mode) . hs-minor-mode))
#+END_SRC

